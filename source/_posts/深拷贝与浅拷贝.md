---
title: 深拷贝与浅拷贝
date: 2018-05-30
tags: 
- ES5
---
### 先分别看以下几个常见的方法

- Object.assign()
- Array.prototype.slice()
- Array.prototype.copyWithin()

> Object.assign()

Object.assign() 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。

```js
var obj = {a: 1, b: {c: 0}}
var copy = Object.assign({}, obj)
console.log(copy) // {a: 1, b: {c: 0}}
obj.a = 2
console.log(copy) // {a: 1, b: {c: 0}}
obj.b.c = 100
console.log(copy) // {a: 1, b: {c: 100}}

// Deep Clone
obj1 = { a: 0 , b: { c: 0}};
let obj3 = JSON.parse(JSON.stringify(obj1));
obj1.a = 4;
obj1.b.c = 4;
console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
```

> slice()

slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分`浅拷贝`到一个新数组对象。且原始数组不会被修改。

```js
var before = [1,3,5,7,9]
var after = before.slice() // [1,3,5,7,9]
before.push(0,10,100) // [1, 3, 5, 7, 9, 0, 10, 100]
console.log(after) // [1,3,5,7,9]
before.push({a:1})

var old = [{a:1}, {b: 2}]
var newer = old.slice() // [{a:1}, {b: 2}]
old[0].a = 'hello'
console.log(newer) // [{a:'hello'}, {b: 2}]
```

> copyWithin() 和 slice() Object.assign() 一样 也是浅复制

### 基本数据类型和引用数据类型

- `Number String Boolean Null Undefined symbol`属于`基本数据类型`
- `Object`属于`引用数据类型`
- 基本类型与引用类型最大的区别实际就是传值与传址的区别。
- 基本类型采用的是值传递。引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。

### 深拷贝和浅拷贝的区别

- `深拷贝` 开辟新的栈，浅拷贝只复制一层对象的属性
- `浅拷贝` 没有开辟新栈，深拷贝则递归复制了所有层级
- 深拷贝和浅拷贝是针对像 `Object Array` 这样的复杂对象

另外，对象比较大，层级也比较多，深复制会带来性能上的问题。

### 实现浅拷贝与深拷贝

```js
// 深拷贝
var deepcopyjson = JSON.parse(JSON.stringify(obj)) // 不能处理函数

//deep copy深拷贝
var deepCopy = function(obj) {
    let keys = Object.keys(obj)
    let newObject = {}
    for (let i = 0; i < keys.length; i++) {
        let key = keys[i]
        if (typeof obj[key] === 'object') { // 如果是引用类型
            newObject[key] = deepCopy(obj[key])
        } else { // 如果是基本类型
            newObject[key] = obj[key]
        }
    }
    return newObject
}
let obj1 = { a: 0 , b: { c: 0}}
let obj2 = deepCopy(obj1)
obj1.b.c = 100
console.log(obj2) // { a: 0 , b: { c: 0}}
```