---
title: 原型链和继承
date: 2018-05-23
tags: 
- ES5
---
## 1. 理解 `instanceof`

> `instanceof` 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。

`object instanceof constructor` 

`object`: 要检测的对象. `constructor`: 某个构造函数

即 ： `instanceof` 运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。

## 2. 理解 `prototype`

> `Object.prototype` 属性表示 `Object` 的原型对象。

```js
// 方法
Object.prototype.hasOwnProperty() // 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的
Object.prototype.toLocaleString() // 直接调用 toString()方法。
Object.prototype.toString() // 返回对象的字符串表示。
Object.prototype.valueOf() // 返回指定对象的原始值。
```

## 3. 理解 `__proto__`

> `Object.prototype` 的 `__proto__`属性是一个访问器属性(一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部 `[[Prototype]]` (一个对象或 null)。

## 4. 理解 原型链与继承

每个对象都有一个私有属性 `[[prototype]]`,它指向它的原型对象`prototype`; 该 `prototype` 对象又具有一个自己的 `prototype`,层层向上直到一个对象的原型为`null`

```js
// 用代码说明上面这段话
var obj = {a: 1}
obj.__proto__ === Object.prototype // true
Object.prototype.__proto__ === null // true

function Func() {
  this.a = 'a'
  this.b = 'b'
}
var myFunc = new Func()
myFunc.__proto__ === Func.prototype // true
Func.__proto__ === Function.prototype // true
Func.prototype.__proto__ === Object.prototype // true
Object.prototype.__proto__ === null // true
```

### 使用不同的方法来创建对象和生成原型链

- 语法结构创建的对象
- 构造器创建的对象
- Object.create 创建的对象
- Class 关键字创建的对象

## 5. 举例

```js
// ES5 构造函数
function A(name) {
  this.name = name
}
A.prototype.toString = function () {
  return this.name
}
var a = new A('fyflying')
console.log('name is ' + a)
```

> Question1: 为什么要把 toString 绑定到 prototype上？ 直接 A.toString... 可以吗？


> Question2: new A 发生了什么


> Function instanceof Object


> Object instanceof Function


## 参考链接

[理解JavaScript的原型链和继承](https://blog.oyanglul.us/javascript/understand-prototype)

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)