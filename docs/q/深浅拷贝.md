# 深浅拷贝

> - 深浅拷贝的原因与目的
> - 深浅拷贝的常用方法
> - 实现深浅拷贝
> - HTML5 的方法实现深浅拷贝

首先深浅拷贝只针对像 Object, Array 这样的引用对象的。
浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。

浅拷贝的方法： `Object.assign()` 与 展开运算符(`...`)<br>
深拷贝的方法： `JSON.parse(JSON.stringify(object))` 但是这个方法存在一些问题:
- 会忽略 symbol undefined 
- 不能序列号函数
- 不能解决循环引用的对象

JavaScript 存储对象是存**地址**的

```js
//浅拷贝实现
function qiankaobei(obj) {
  if(typeof obj !== 'object') {
    console.error('obj arguments need')
  }
  var newObj = obj instanceof Array ? [] : {}
  for(var key in obj) {
    if(obj.hasOwnProperty(key)) {
      newObj[key] = obj[key]
    }
  }
  return newObj;
}
```

```js
// 深拷贝实现
function shenkaobei(obj) {
  if(typeof obj !== 'object') {
    console.error('object arguments need')
  }
  var newObj = obj instanceof Array ? [] : {}
  for(var key in obj) {
    if(obj.hasOwnProperty(key)) {
      newObj[key] = typeof obj[key] === 'object' ? shenkaobei(obj[key]) : obj[key] // 递归
    }
  }
  return newObj;
}
```

深拷贝中，使用 H5 APi 比 `Json.parse(Json.stringify)` 支持更多类型:
Date, RegExp, Map, Set, Blob, FileList, ImageData, sparse and typed Array.

```js
// 使用 HTML5 实现 深拷贝
// history.pushState() and history.replaceState() 结构化克隆
// 会导致浏览器反应迟钝

// history API
const structuredClone = obj => {
  const oldState = history.state;
  history.replaceState(obj, null);
  const clonedObj = history.state;
  history.replaceState(oldState, null);
  return clonedObj;
};

var obj = { a: 0, b: { c: 0 } };

var deepCloneObj = structuredClone(obj)

obj.a = 1
obj.b.c = 2

console.log(deepCloneObj.a) // 0
console.log(deepCloneObj.b.c) // 0


// notification API 
const structuredClone = obj => {
  const n = new Notification("", {data: obj, silent: true});
  n.onshow = n.close.bind(n);
  return n.data;
};

var obj = { a: 0, b: { c: 0 } };

var deepCloneObj = structuredClone(obj)

obj.a = 1
obj.b.c = 2

console.log(deepCloneObj.a) // 0
console.log(deepCloneObj.b.c) // 0
```

```js
// lodash 实现 深拷贝
// in node.js
function deepClone(obj) {
  var copy;

  // Handle the 3 simple types, and null or undefined
  if (null == obj || "object" != typeof obj) return obj;

  // Handle Date
  if (obj instanceof Date) {
    copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  // Handle Array
  if (obj instanceof Array) {
    copy = [];
    for (var i = 0, len = obj.length; i < len; i++) {
        copy[i] = clone(obj[i]);
    }
    return copy;
  }

  // Handle Function
  if (obj instanceof Function) {
    copy = function() {
      return obj.apply(this, arguments);
    }
    return copy;
  }

  // Handle Object
  if (obj instanceof Object) {
      copy = {};
      for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
      }
      return copy;
  }

  throw new Error("Unable to copy obj as type isn't supported " + obj.constructor.name);
}
```