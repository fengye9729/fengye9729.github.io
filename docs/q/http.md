# http

> HTTP

HTTP 超文本传输协议，无状态的协议，是基于 TCP/IP 的关于数据在万维网如何通信的协议，底层是 TCP/IP。
HTTP 请求由三部分构成：请求行 首部 实体
请求行由三部分构成：请求方法 URL 协议版本 （ GET `/images/logo.gif HTTP/1.1`）
HTTP 请求有：Get Head Post Put Delete Connect Options Trace Patch

> Get 与 Post 的区别

- get 和 post 本质上就是 tcp 连接，并无差别。但是由于 HTTP的规定和浏览器服务器的限制，导致在应用中体现了不同
- get 把参数写在 URL, post 通过 request body 传递参数
- get 在浏览器回退时是无害的，post 会再次请求
- get 的 URL 地址能被书签，post 不可以
- get 能缓存, post 不能
- post 相对来说比较安全； get 请求会被浏览器保存历史记录
- URL 长度受限影响 get
- post 支持更多的编码类型

状态码：响应的状态，清晰的了解到请求是成功还是失败
2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务端错误

> TLS 传输层安全协议

HTTPS 通过 HTTP 传输信息，通过 TLS 协议进行了加密
HTTP 存在的问题：（为什么需要加密）
- 可能被窃听（http 本身不具备加密功能，使用明文传输数据）
- 认证问题 （无法确认服务器|客户端是否真实，无法确认通信者是否有权限）
- 可能被篡改（中间人攻击）

SSL/TLS 协议是为了解决这三大风险而设计的，希望达到
- 所有信息都是加密传播，第三方无法窃听
- 配备身份证书，方式身份被冒充
- 具有校验机制，一旦被篡改，通信双方就会立刻被发现

**TLS 加密方式**： 对称加密 & 非对称加密
**TLS 握手**

> HTTP2

HTTP2 解决了 HTTP1 存在的大部分性能问题，但是要考虑到兼容性，如何优雅降级是个问题
HTTP2 大幅提升了网页的性能
在 HTTP1 中，为了考虑性能，我们使用了 雪碧图、将小图内联、使用多个域名（因为浏览器限制同一个域名下的请求数量）
当请求数量很多时，会导致**队头阻塞** （在达到最大请求数量时，剩余的资源需要等待其他资源请求完后才能发起请求）

HTTP2 采用 **多路复用** ，只通过一个 TCP 连接就能传输所有的请求数据，解决了浏览器同一个域名下的请求数量限制问题
两个概念：帧和流
帧：最小的数据单位，多个帧组成数据流，每个帧会标志出属于哪个流
多路复用：在一个 TCP 连接中存在多条流，可以发起多个请求，对端通过帧的标志可以识别出属于哪个流，避免了队头阻塞，极大的提升了性能

HTTP2 采用 **二进制传输**
HTTP1 通过文本传输数据，在 HTTP2 中所有的数据会被分割，采用二进制传输

HTTP2 采用 **Head 压缩**
HTTP1 使用文本的形式传输 Header 若 Header 中存在cookie ，那么每次传输都需要重复传输几百到几千的字节
HTTP2 HPACK 压缩，对传输的 header 进行编码，减少了 header 的大小，并在两端维护索引表，用于记录出现过的 header, 后面再传输过程中就可以传输已经传输过的 header 的键名，对端收到后通过键名寻找键值

HTTP2 采用 **服务端 push**
服务端可以在客户端某次请求后，主动推送其他资源
因为某些资源客户端一定会请求，采用服务端 push, 提前给客户端推送必要的资源，可以减少一点延迟时间。

> HTTP3

HTTP2 底层支撑的 TCP 协议存在问题，一个域名对应一个 tcp 连接，当连接中出现丢包，整个 tcp 都要等待重传，导致后面的数据都被阻塞
但是对于 HTTP1 ,可以开启多个TCP 连接，出现丢包只会影响其中一条连接，剩余的连接还能正常传输
但是呢，不可能修改 TCP 连接，因为它存在时间很长，充斥在各个设备上，而且协议是由操作系统实现，更改它不现实。
于是 Google 创造了 基于 UDP 的 QUIC 协议

> websocket